#pragma once

#include <application_framework_api.h>

#include <kan/api_common/c_header.h>
#include <kan/container/dynamic_array.h>
#include <kan/container/interned_string.h>
#include <kan/reflection/markup.h>
#include <kan/universe/universe.h>

/// \file
/// \brief Contains public API for application framework.
///
/// \par Definition
/// \parblock
/// Application framework is a common code for configuring and launching applications that use universe unit and
/// context plugin system. In most cases, this file API should not be used directly, as it only provides ways to
/// configure and launch applications, which is usually done by autogenerated launchers.
/// \endparblock
///
/// \par Programs
/// \parblock
/// Every application is a set of one or more programs. Every program is a logically separate instrument that provides
/// different features, but all programs share common goal and common code. For example, application "NewShooterGame"
/// would consist of 3 programs: "Server", "Client" and "Editor". All these programs share some common code and common
/// goal (they're part of "NewShooterGame"), but also have their own code, data and launchers.
/// \endparblock
///
/// \par Application architecture
/// \parblock
/// Application consists of the following parts:
/// - Core library. Main dynamic library that contains common units that are required to launch any program in
///   application. For example, universe, context and context systems.
/// - Core configuration. This configuration contains information that is required to launch any program in application.
/// - World directory. This directory contains all worlds and is processed by universe world definition system.
/// - Plugins. They contain additional program-specific logic that is loaded through reflection. For example specific
///   universe mutators and specific data types. It is advised to put as much logic as possible to plugins instead of
///   core library as plugins support code hot reload.
/// - Program configurations. They configuration files contain instructions how to launch specific programs.
/// - Program launchers. Optional trivial executables that call application framework with correct configurations.
/// \endparblock
///
/// \par Plugins
/// \parblock
/// Plugin is essentially a dynamic library with generated reflection, which reflection is then imported by application.
/// Additionally, plugins must only link to core library or to core plugins. Core plugin is a plugin that is specified
/// in core configuration for context plugin system and therefore is always available. This requirement is needed to
/// keep plugin management easy and straightforward.
///
/// Goal of the plugin system is to provide simple yet powerful tool for building modular applications. The fact that
/// they only provide reflection makes it easy to understand them and to work with them, but does not limit their
/// capabilities as reflection is frequently used across different units. For example, universe unit is fully
/// reflection-driven and schedulers, mutators and data types from plugins can be freely used with universe.
/// \endparblock
///
/// \par Configuration
/// \parblock
/// Core configuration contains both common information and information that must be identical for all the programs:
///
/// - It contains list of additional non-standard systems to request from core library if needed for all programs and
///   their configurations.
/// - It contains name of the definition for the universe root world, that is shared between all the programs. This
///   world contains common pipelines and logic that is required by every program, for example resource management.
///   Requiring all programs to have common world makes it possible to run several programs inside one universe if
///   needed, which is useful for programs like editor: they would like to run game programs inside the same universe
///   and context. Definition is loaded through universe world definition system.
///
/// Program configurations contain program specific data:
///
/// - It contains list of additional program-specific systems from core library with their configurations.
/// - It contains log name used to save program logs.
/// - It contains name for the program world definition, that is instanced as root world child. The reason for having
///   separate shared root world and separate program worlds is described above. Definition is loaded through universe
///   world definition system.
/// - It contains auto build flag and command for hot reload.
///
/// When system is enabled several times, for example in core configuration and program configuration, its configuration
/// is merged through subsequent patch application. Program configuration patches are applied after core configuration
/// patches. It makes it possible for programs to alter core systems configuration when needed.
/// \endparblock

KAN_C_HEADER_BEGIN

/// \brief Application framework exit code when it failed to read configuration.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_READ_CONFIGURATION -1

/// \brief Application framework exit code when it failed to initialize platform unit application backend.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_INITIALIZE_PLATFORM -2

/// \brief Application framework exit code when it failed to correctly assemble execution context.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_ASSEMBLE_CONTEXT -3

/// \brief Application framework exit code when it failed to find required systems.
/// \details Required systems are application system, application framework system, universe system
///          universe world definition system and update system.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_CREATE_REQUIRED_SYSTEMS -4

/// \brief Application framework exit code when it failed to find definitions for either root or program worlds.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_FIND_WORLD_DEFINITIONS -5

/// \brief Returns allocation group that should be used to allocate strings inside configuration structures.
APPLICATION_FRAMEWORK_API kan_allocation_group_t kan_application_framework_get_configuration_allocation_group (void);

/// \brief Configuration node that contains context system name and optionally its configuration as patch.
struct kan_application_framework_system_configuration_t
{
    kan_interned_string_t name;
    kan_reflection_patch_t configuration;
};

APPLICATION_FRAMEWORK_API void kan_application_framework_system_configuration_init (
    struct kan_application_framework_system_configuration_t *instance);

APPLICATION_FRAMEWORK_API void kan_application_framework_system_configuration_shutdown (
    struct kan_application_framework_system_configuration_t *instance);

/// \brief Structure for application framework core configuration.
struct kan_application_framework_core_configuration_t
{
    /// \brief List of enabled systems with their configurations.
    KAN_REFLECTION_DYNAMIC_ARRAY_TYPE (struct kan_application_framework_system_configuration_t)
    struct kan_dynamic_array_t enabled_systems;

    /// \brief Name of the definition of the universe shared root world.
    kan_interned_string_t root_world;

    /// \brief Path to file used as a lock file to prevent concurrent builds from several auto build triggers.
    char *auto_build_lock_file;
};

APPLICATION_FRAMEWORK_API void kan_application_framework_core_configuration_init (
    struct kan_application_framework_core_configuration_t *instance);

APPLICATION_FRAMEWORK_API void kan_application_framework_core_configuration_shutdown (
    struct kan_application_framework_core_configuration_t *instance);

/// \brief Structure for application framework per-program configuration.
struct kan_application_framework_program_configuration_t
{
    /// \brief List of enabled systems with their configuration.
    /// \details If system is listed both in core configuration and in program configuration,
    ///          then configurations are merged and program configuration is applied on top of core configuration.
    KAN_REFLECTION_DYNAMIC_ARRAY_TYPE (struct kan_application_framework_system_configuration_t)
    struct kan_dynamic_array_t enabled_systems;

    /// \brief Name used for log files for this program.
    kan_interned_string_t log_name;

    /// \brief Name of the definition of the program-specific universe child world.
    kan_interned_string_t program_world;

    /// \brief Whether auto build feature is enabled.
    /// \details Auto build is a development-only feature that executes given command every time in a loop with timed
    ///          delay between executions. As build system already checks file times, there is no sense to use our
    ///          own file system watcher: it would do the same thing and build system might do it better.
    bool enable_auto_build;

    /// \brief If ::enable_auto_build and not NULL, this command is executed every time any application window
    ///        is focused in order to update and hot reload plugins if there are any changes.
    char *auto_build_command;

    /// \brief Delay between several auto build execution attempts.
    kan_time_size_t auto_build_delay_ns;
};

APPLICATION_FRAMEWORK_API void kan_application_framework_program_configuration_init (
    struct kan_application_framework_program_configuration_t *instance);

APPLICATION_FRAMEWORK_API void kan_application_framework_program_configuration_shutdown (
    struct kan_application_framework_program_configuration_t *instance);

/// \brief Wrapper for kan_application_framework_run_with_configuration that loads configuration from given paths.
APPLICATION_FRAMEWORK_API int kan_application_framework_run (const char *core_configuration_path,
                                                             const char *program_configuration_path,
                                                             kan_instance_size_t arguments_count,
                                                             char **arguments);

/// \brief Executes application framework with provided configuration and registry used to read it.
///        Returns after execution is completed.
/// \details Provided registry and configuration are automatically destroyed when application framework succeeds in
///          context assembly. The only exception is when
///          KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_INITIALIZE_PLATFORM error code is returned as platform
///          initialization happens before context assembly.
APPLICATION_FRAMEWORK_API int kan_application_framework_run_with_configuration (
    struct kan_application_framework_core_configuration_t *core_configuration,
    struct kan_application_framework_program_configuration_t *program_configuration,
    kan_instance_size_t arguments_count,
    char **arguments,
    kan_reflection_registry_t configuration_loading_registry);

KAN_C_HEADER_END
