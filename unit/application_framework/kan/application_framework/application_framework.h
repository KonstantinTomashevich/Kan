#pragma once

#include <application_framework_api.h>

#include <kan/api_common/c_header.h>
#include <kan/container/dynamic_array.h>
#include <kan/container/interned_string.h>
#include <kan/universe/universe.h>

/// \file
/// \brief Contains public API for application framework.
///
/// \par Definition
/// \parblock
/// Application framework is a common code for configuring and launching applications that use universe unit and
/// context plugin system. In most cases, this file API should not be used directly, as it only provides ways to
/// configure and launch applications, which is usually done by autogenerated launchers.
/// \endparblock
///
/// \par Programs
/// \parblock
/// Every application is a set of one or more programs. Every program is a logically separate instrument that provides
/// different features, but all programs share common goal and common code. For example, application "NewShooterGame"
/// would consist of 3 programs: "Server", "Client" and "Editor". All these programs share some common code and common
/// goal (they're part of "NewShooterGame"), but also have their own code, data and launchers.
/// \endparblock
///
/// \par Application architecture
/// \parblock
/// Application consists of the following parts:
/// - Core library. Main dynamic library that contains common units that are required to launch any program in
///   application. For example, universe, context and context systems.
/// - Core configuration. This configuration contains information that is required to launch any program in application.
/// - World directory. This directory contains all worlds and is processed by universe world definition system.
/// - Plugins. They contain additional program-specific logic that is loaded through reflection. For example specific
///   universe mutators and specific data types.
/// - Program configurations. They configuration files contain instructions how to launch specific programs.
/// - Program launchers. Optional trivial executables that call application framework with correct configurations.
/// \endparblock
///
/// \par Plugins
/// \parblock
/// Plugin is essentially a dynamic library with generated reflection, which reflection is then imported by application.
/// Additionally, plugins must only link to core library or to core plugins. Core plugin is a plugin that is specified
/// in core configuration and therefore is always available. This requirement is needed to keep plugin management easy
/// and straightforward.
///
/// Goal of the plugin system is to provide simple yet powerful tool for building modular applications. The fact that
/// they only provide reflection makes it easy to understand them and to work with them, but does not limit their
/// capabilities as reflection is frequently used across different units. For example, universe unit is fully
/// reflection-driven and schedulers, mutators and data types from plugins can be freely used with universe.
/// \endparblock
///
/// \par Core configuration
/// \parblock
/// Core configuration contains both common information and information that must be identical for all the programs:
///
/// - It contains list of additional non-standard systems to request from core library if needed.
///   As core library cannot contain program-specific logic, systems must be shared too.
/// - It contains list of core plugins. These plugins are always loaded by every program, therefore it allows other
///   plugins to depend on them without introducing difficult dependency routines.
/// - It contains list of resource directories and packs, that are used by all programs.
/// - It contains name of the definition for the universe root world, that is shared between all the programs. This
///   world contains common pipelines and logic that is required by every program, for example resource management.
///   Requiring all programs to have common world makes it possible to run several programs inside one universe if
///   needed, which is useful for programs like editor: they would like to run game programs inside the same universe
///   and context. Definition is loaded through universe world definition system.
/// - It contains path to plugin directory.
/// - It contains path to world definitions directory.
/// \endparblock
///
/// \par Program configuration
/// \parblock
/// Program configurations contain program specific data:
///
/// - It contains plugins that are being used by this program excluding core plugins.
/// - It contains resource directories and packs that are specific to this program.
/// - It contains name for the program world definition, that is instanced as root world child. The reason for having
///   separate shared root world and separate program worlds is described above. Definition is loaded through universe
///   world definition system.
/// \endparblock

KAN_C_HEADER_BEGIN

/// \brief Application framework exit code when it failed to read configuration.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_READ_CONFIGURATION -1

/// \brief Application framework exit code when it failed to initialize platform unit application backend.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_INITIALIZE_PLATFORM -2

/// \brief Application framework exit code when it failed to correctly assemble execution context.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_ASSEMBLE_CONTEXT -3

/// \brief Application framework exit code when it failed to find definitions for either root or program worlds.
#define KAN_APPLICATION_FRAMEWORK_EXIT_CODE_FAILED_TO_FIND_WORLD_DEFINITIONS -4

/// \brief Returns allocation group that should be used to allocate strings inside configuration structures.
APPLICATION_FRAMEWORK_API kan_allocation_group_t kan_application_framework_get_configuration_allocation_group (void);

/// \brief Describes used resource directory for application framework configuration.
struct kan_application_framework_resource_directory_t
{
    /// \brief Real path to resource directory.
    char *path;

    /// \brief Path to which this resource directory should be mounted.
    char *mount_path;
};

APPLICATION_FRAMEWORK_API void kan_application_framework_resource_directory_init (
    struct kan_application_framework_resource_directory_t *instance);

APPLICATION_FRAMEWORK_API void kan_application_framework_resource_directory_shutdown (
    struct kan_application_framework_resource_directory_t *instance);

/// \brief Describes used resource read-only pack for application framework configuration.
struct kan_application_framework_resource_pack_t
{
    /// \brief Real path to resource read-only pack.
    char *path;

    /// \brief Path to which this resource pack should be mounted.
    char *mount_path;
};

APPLICATION_FRAMEWORK_API void kan_application_framework_resource_pack_init (
    struct kan_application_framework_resource_pack_t *instance);

APPLICATION_FRAMEWORK_API void kan_application_framework_resource_pack_shutdown (
    struct kan_application_framework_resource_pack_t *instance);

/// \brief Structure for application framework core configuration.
struct kan_application_framework_core_configuration_t
{
    /// \brief Additional user systems to be requested.
    /// \meta reflection_dynamic_array_type = "kan_interned_string_t"
    struct kan_dynamic_array_t systems;

    /// \brief List of core plugins.
    /// \meta reflection_dynamic_array_type = "kan_interned_string_t"
    struct kan_dynamic_array_t plugins;

    /// \brief List of core resource directories.
    /// \meta reflection_dynamic_array_type = "struct kan_application_framework_resource_directory_t"
    struct kan_dynamic_array_t resource_directories;

    /// \brief List of core resource read-only packs.
    /// \meta reflection_dynamic_array_type = "struct kan_application_framework_resource_pack_t"
    struct kan_dynamic_array_t resource_packs;

    /// \brief Name of the definition of the universe shared root world.
    kan_interned_string_t root_world;

    /// \brief Path to the the plugin directory.
    char *plugin_directory_path;

    /// \brief Path to the the universe world definitions directory.
    char *world_directory_path;

    /// \brief Whether universe world definition directory should be observed for changes.
    kan_bool_t observe_world_definitions;

    /// \brief Delay between changes in universe world definition directory and definition reload.
    uint64_t world_definition_rescan_delay_ns;
};

APPLICATION_FRAMEWORK_API void kan_application_framework_core_configuration_init (
    struct kan_application_framework_core_configuration_t *instance);

APPLICATION_FRAMEWORK_API void kan_application_framework_core_configuration_shutdown (
    struct kan_application_framework_core_configuration_t *instance);

/// \brief Structure for application framework per-program configuration.
struct kan_application_framework_program_configuration_t
{
    /// \brief List of program-specific plugins.
    /// \meta reflection_dynamic_array_type = "kan_interned_string_t"
    struct kan_dynamic_array_t plugins;

    /// \brief List of program-specific resource directories.
    /// \meta reflection_dynamic_array_type = "struct kan_application_framework_resource_directory_t"
    struct kan_dynamic_array_t resource_directories;

    /// \brief List of program-specific resource read-only packs.
    /// \meta reflection_dynamic_array_type = "struct kan_application_framework_resource_pack_t"
    struct kan_dynamic_array_t resource_packs;

    /// \brief Name of the definition of the program-specific universe child world.
    kan_interned_string_t program_world;
};

APPLICATION_FRAMEWORK_API void kan_application_framework_program_configuration_init (
    struct kan_application_framework_program_configuration_t *instance);

APPLICATION_FRAMEWORK_API void kan_application_framework_program_configuration_shutdown (
    struct kan_application_framework_program_configuration_t *instance);

/// \brief Wrapper for kan_application_framework_run_with_configuration that loads configuration from given paths.
APPLICATION_FRAMEWORK_API int kan_application_framework_run (const char *core_configuration_path,
                                                             const char *program_configuration_path,
                                                             uint64_t arguments_count,
                                                             char **arguments);

/// \brief Executes application framework with provided configuration. Returns after execution is completed.
APPLICATION_FRAMEWORK_API int kan_application_framework_run_with_configuration (
    const struct kan_application_framework_core_configuration_t *core_configuration,
    const struct kan_application_framework_program_configuration_t *program_configuration,
    uint64_t arguments_count,
    char **arguments);

KAN_C_HEADER_END
