# Render Pipeline Language

## Definition

Render pipeline language is GPU programming language which is being developed specifically for Kan project.
It aims to fully represent GPU pipelines and provide enough information to construct pipeline state object right away.
Currently, it is in early prototype stage.

## Goals

- To provide enough information for constructing pipeline stage objects right away with requiring any additional
  context. Having all the information in pipeline file is one of the solutions to PSO hiccup issue.

- To provide enough usable information to build outer high-level objects like materials. For example, pipeline should
  provide information about all attribute-driven and uniform-driven parameters that can be specified through material.

- To reduce amount of hardcode between CPU code and GPU code: there should be no hardcoded locations and bindings.
  Instead, CPU code should rely on provided metadata including parameter tags.

- To reduce amount of time needed to compile uber shader variants by getting rid of preprocessing at all. It is common
  practice to have one shader with lots of macros and then compiling it like 5000 times with different defines. In this
  case the same code is getting parsed repeatedly which is not effective.

## Principles

- Pipelines are able to declare options: values that can be set after parsing and before compilation in order to
  customize pipeline.

- Conditionals are compile-time expressions that only operate on options and are used to customize pipeline without
  preprocessing step.

- Pipeline settings are declared in global scope to express information needed to configure pipeline creation.

- All input and output data is declared through named and typed buffers that can also be visible through pipeline
  metadata.

- All structure and buffer fields might contain attached meta tags that can be used by outer logic to bind its data
  like joint matrices to concrete buffers and variables without requiring them to be named in some hardcoded way.

- All bindings and locations are autogenerated and cannot be hardcoded in any way.

- Samplers and images are coupled and all sampler settings are declared in sampler using the same setting syntax.

- All settings, buffers and samplers can be exported to separate structure during compilation than can be serialized
  and later used for high-level object construction.

- Compilation is split in 3 steps: parse step, resolve step and emit step. Parse step produces intermediate data that
  includes conditionals and can be used to produce multiple variants of uber shader. Resolve step processes options,
  gets rid of compile time expressions and produces target-agnostic intermediate data. Emit step uses resolved data
  to construct pipeline metadata and/or emit code in specific language, like SPIRV.

## Options

Options are used to specify how different pipelines variants can be configured in more precise and strict way than it
is usually done through macros.

Currently, there are 2 types of option data:

- `flag` options are used for on/off type of data, like whether some feature is enabled.
- `count` options are used for unsigned positive numbers, like maximum size of joint matrices array.

Also, there are 2 classes of options:

- `global` options are allowed to be used everywhere and can be used in any conditional.
- `instance` options can only be used in places where they do not affect which buffers are generated, which data
  they hold and which samplers are generated (therefore, sampler settings are `global`-only).

Goal of these classes is to make it easier for material system to follow proper configuration routine. Every pass
supported by material should accept the same data format, therefore buffers should not be different, which can be
ensured by specifying `global` options for the whole material and allowing passes to only specify `instance` options
by themselves.

Options are declared in global scope and follow the pattern: `global|instance flag|count <option_name> <option_value>`
with `on|off` for `flag` option values and unsigned decimal literals for `count` option value. Below are the examples
of option declarations in global scope:

```
global flag enable_skinning on;
global flag skinning_2_weights on;
global flag skinning_4_weights off;
global count max_joints 256;
global flag support_instancing on;
instance flag wireframe off;
```

## Conditional prefixes

Conditional prefixes are used to specify the compile-time condition on which the expression after them is enabled.
Every conditional prefix should be an expression that only uses options and always evaluates to boolean value.
When conditional prefix is evaluated as `false`, expression after that prefix is excluded from the context.
Below are the examples of conditional prefixes:

```
conditional (!wireframe)
conditional (enable_skinning && skinning_2_weights)
```

## Settings

Settings are used to provide information for pipeline configuration. Accepted settings and their types depend on
pipeline type (for example, classic graphics or compute) which is only known to CPU during compilation.

Settings are declared in global scope and follow the pattern:
`conditional_prefix? <setting_name> flag_value|integer_value|floating_value|string_value
(block unsigned_integer_value)?` with `conditonal_prefix` being allowed to use instance options, `flag_value` being
`on|off`, `integer_value` being signed integer literal, `floating_value` being signed floating literal and string value
be C-style `"`-guarded string literal, and optional block suffix for specifying blocks for settings that require block
context (for example there can be several color outputs, therefore we must specify color output index as block index).
Below are the examples of setting declarations in global scope:

```
conditional (!wireframe) setting polygon_mode "fill";
conditional (wireframe) setting polygon_mode "wireframe";
setting cull_mode "back";
setting depth_test on;
setting depth_write on;
setting color_output_use_blend on block 0;
setting color_output_source_color_blend_factor "source_color" block 1;
```

## Meta prefixes

Meta prefixes are used to add textual meta tags to struct and buffer fields, that can be later used on higher level to
identify required parameters. Meta prefixes follow the pattern: `meta \( tag (, tag)* \)` with `tag` as any C-style
identifier. Below are the examples of meta prefixes:

```
meta (hidden, model_joint_matrices)
meta (hidden, projection_view_matrix)
```

## Inbuilt types

There is list of currently supported inbuilt types:

- `f1` -- 32-bit floating point scalar.
- `f2`, `f3` and `f4` -- 2, 3 and 4 dimensional vectors of 32-bit floating point scalars.
- `i1` -- 32-bit signed integer scalar.
- `i2`, `i3`, `i4` -- 2, 3 and 4 dimensional vectors of 32-bit signed integer scalars.
- `f3x3`, `f4x4` -- 3x3 and 4x4 column-major matrices of 32-bit floating point scalars.

## Type usage syntax

Type can be specified using syntax: `type_name ((\[ array_dimension_expression \])+ | ...)?` with type_name being 
inbuilt type name or structure name and array_dimension_expression being a compile-time expression that selects size of
array dimension. `...` can be used instead of array suffix in order to declare runtime-sized array. But keep in mind
that runtime sized arrays are only supported in structures and buffers and always should be the last field.
If type is used for structures or buffers, only `global` options can be used inside expression.
Otherwise, `instance` options are allowed.

Below are the examples of types:

```
f3
joint_data_t
f4x4[max_joints]
f4x4...
```

## Structs

Structs are used to declare complex data structures the same way as it is done in C or GLSL.

Struct declaration syntax is:

```
conditional_prefix? struct <struct_name>
{
    (conditional_prefix? meta_prefix? type <field_name>;)+
};
```

Struct declaration example:

```
conditional (enable_skinning) struct joint_data_t
{
    meta (hidden, model_joint_matrices)
    f4x4[max_joints] model_joints;
};
```

## Descriptor sets

There are several inbuilt descriptor sets that correspond to the common usage pattern:

- `set_pass` is advised for data that stays bound during the whole render pass like projection view matrix.
- `set_material` is advised for data that is shared between lots of objects and corresponds to
  high level concept of materials.
- `set_object` is advised for data unique for scene object, but when binding is rarely changed. For example, object may
  store its data in its own uniform buffer and update this buffer without changing descriptor set.
- `set_unstable` is advised for data that is unique for every scene object and which binding changing every frame.
  For example, data that is being sent from CPU to GPU every frame and has varying size can be passed through
  unstable sets with the help of frame lifetime allocators.

Any set keyword inside declaration syntax is called `set_prefix` below.

Hardcoded set names are used to make writing shaders more explicit and easy to understand as render pipeline language
is designed to provide as much information as possible to the high level material system instead of just arbitrary set 
numbers. Also, we have only 4 descriptor sets as it is the minimum guaranteed number of supported sets on modern GPUs.

## Buffers

Buffer is a group variables that serve the same purpose and usually stored in one physical buffer object.
There are several types of buffers:

- `vertex_attribute_buffer` represents buffer of vertex attributes. Fields of this buffer are the attributes of one
  vertex. Does not support runtime sized arrays.
- `instanced_attribute_buffer` represents buffer of per-instance attributes. Fields of this buffer are the attributes
  of one instanced geometry. Does not support runtime sized arrays.
- `uniform_buffer` represents a classic uniform buffer object with `std140` memory layout. Requires `set_prefix`.
- `read_only_storage_buffer` represents a classic storage buffer which is read-only and has `std430` memory layout.
  Requires `set_prefix`.
- `vertex_stage_output` is an abstract buffer which is technically not a buffer and used for sharing vertex stage
  data with other pipeline stages.
- `fragment_stage_output` is an abstract buffer which is technically not a buffer and used for fragment stage output.

Buffer declaration syntax is close to struct declaration syntax:

```
conditional_prefix? set_prefix_if_supported_by_type buffer_type <buffer_name>
{
    (conditional_prefix? meta_prefix? type <field_name>;)+
};
```

Buffer declaration examples:

```
vertex_attribute_buffer vertex
{
    f3 position;
    f3 normal;
    f2 uv;

    conditional (enable_skinning && skinning_2_weights) i2 joint_indices;
    conditional (enable_skinning && skinning_2_weights) f2 joint_weights;

    conditional (enable_skinning && skinning_4_weights) i4 joint_indices;
    conditional (enable_skinning && skinning_4_weights) f4 joint_weights;
};

conditional (support_instancing) instanced_attribute_buffer instance_vertex
{
    f4 color_multiplier;

    meta (hidden, model_space_matrix)
    f4x4 model_space;

    conditional (enable_skinning)
    meta (hidden, joint_offset_index)
    i1 joint_offset;
};

conditional (!support_instancing) set_material uniform_buffer material
{
    f4 color_multiplier;
};

conditional (support_instancing && enable_skinning) set_unstable read_only_storage_buffer joints
{
    f4x4... transforms;
};
```

Buffers are exposed in metadata (excluding `vertex_stage_output` and `fragment_stage_output` ones). Depending on buffer
type, its fields can be exposed as named parameters, attributes or both. For parameter generation, buffer flattening
is used. It means that buffer data is represented as tree and then only tree leaves are exposed as parameters, where
parameter name is equal to path from tree root to parameter leaf. Runtime sized array generate tail parameters if their 
item type is structure. Also, arrays of structs currently do not participate in parameter generation for simplification 
as it is not needed at the moment.

## Samplers

Currently, there is only one supported sampler type: `sampler2d`. More types will be supported in the future.

Samples declaration syntax is:

```
conditional_prefix set_prefix sampler_type <sampler_name>;
```

Sampler declaration example:

```
set_material sampler_2d diffuse_color;
```

To sample data from sampler, sampler should be called like a function. Below are arguments for different sampler types:

- `sampler2d` requires one `f2` argument: 2d coordinates.

## Functions

Function declaration syntax is close to C with a few exceptions:

- Function can only return non-array types.
- If function doesn't return anything, `void` should be used instead of return type.
- Functions without arguments must be declared as `<return_type> <function_name> (void)`.
- Every function argument is allowed to have conditional prefix.

There is also some additional cases where conditionals can be used in function code:

- Scopes can be conditional, for example:

```
conditional (enable_skinning)
{
    // Logic when skinning is enabled.
}
conditional (!enable_skinning)
{
    // Logic when skinning is disabled.
}
```

- There is a conditional alias syntax for situations where we need to refer to different buffers or variables depending
  on pipeline options:

```
conditional (support_instancing) alias (joints, instance_storage.joint_data.model_joints)
conditional (!support_instancing) alias (joints, uniforms.joint_data.model_joints)
// Below, "joints" can be used as a normal variable name.
// Conditional aliases have the same visiblity as variable inside scope.
```
