# Render Pipeline Language

## Definition

Render pipeline language is GPU programming language which is being developed specifically for Kan project.
It aims to fully represent GPU pipelines and provide enough information to construct pipeline state object right away.
Currently, it is in early prototype stage.

## Goals

- To provide enough information for constructing pipeline stage objects right away without requiring any additional
  context. Having all the information in pipeline file is one of the solutions to PSO hiccup issue.

- To provide enough usable information to build outer high-level objects like materials. For example, pipeline should
  provide information about all attribute-driven and uniform-driven parameters that can be specified through material.

- To reduce amount of hardcode between CPU code and GPU code: there should be no hardcoded locations and bindings.
  Instead, CPU code should rely on provided metadata including parameter tags.

- To reduce amount of time needed to compile uber shader variants by getting rid of preprocessing at all. It is common
  practice to have one shader with lots of macros and then compiling it like 5000 times with different defines. In this
  case the same code is getting parsed repeatedly which is not effective.

## Principles

- Pipelines are able to declare options: values that can be set after parsing and before compilation in order to
  customize pipeline.

- Conditionals are compile-time expressions that only operate on options and are used to customize pipeline without
  preprocessing step.

- Pipeline settings are declared in global scope to express information needed to configure pipeline creation.

- All input and output data is declared through named and typed buffers that can also be visible through pipeline
  metadata.

- All structure and buffer fields might contain attached meta tags that can be used by outer logic to bind its data
  like joint matrices to concrete buffers and variables without requiring them to be named in some hardcoded way.

- All bindings and locations are autogenerated and cannot be hardcoded in any way.

- Samplers and images are always decoupled as separate objects.

- All settings, buffers, samplers and images can be exported to separate structure during compilation than can be 
  serialized and later used for high-level object construction.

- Compilation is split in 3 steps: parse step, resolve step and emit step. Parse step produces intermediate data that
  includes conditionals and can be used to produce multiple variants of uber shader. Resolve step processes options,
  gets rid of compile time expressions and produces target-agnostic intermediate data. Emit step uses resolved data
  to construct pipeline metadata and/or emit code in specific language, like SPIRV.

## Options

Options are used to specify how different pipelines variants can be configured in more precise and strict way than it
is usually done through macros.

Currently, there are 2 types of option data:

- `flag` options are used for on/off type of data, like whether some feature is enabled.
- `count` options are used for unsigned positive numbers, like maximum size of joint matrices array.

Also, there are 2 classes of options:

- `global` options are allowed to be used everywhere and can be used in any conditional.
  They are primarily used to dictate things that affect input interface of the pipeline.
- `instance` options can only be used in places where they do not affect input interface of the pipeline.

The reason for having two classes is making it easier for the high level code to ensure that several pipelines share
the same input interface and can be classified as a family of the pipelines. It is very useful for materials in 
particular, as we'd like to ensure that all material pipelines for any pass have the same input interface excluding 
pass set input. It can be ensured through setting `global` options for the whole material only and using only
`instance` options for customizing the pass pipelines.

Options are declared in global scope and follow the pattern: `global|instance flag|count <option_name> <option_value>`
with `on|off` for `flag` option values and unsigned decimal literals for `count` option value. Below are the examples
of option declarations in global scope:

```
global flag enable_skinning on;
global flag skinning_2_weights on;
global flag skinning_4_weights off;
global count max_joints 256;
global flag support_instancing on;
instance flag wireframe off;
```

## Conditional prefixes

Conditional prefixes are used to specify the compile-time condition on which the expression after them is enabled.
Every conditional prefix should be an expression that only uses options and always evaluates to boolean value.
When conditional prefix is evaluated as `false`, expression after that prefix is excluded from the context.
Below are the examples of conditional prefixes:

```
conditional (!wireframe)
conditional (enable_skinning && skinning_2_weights)
```

## Settings

Settings are used to provide information for pipeline configuration. Accepted settings and their types depend on
pipeline type (for example, classic graphics or compute) which is only known to CPU during compilation.

Settings are declared in global scope and follow the pattern:
`conditional_prefix? <setting_name> flag_value|integer_value|floating_value|string_value
(block unsigned_integer_value)?` with `conditonal_prefix` being allowed to use instance options, `flag_value` being
`on|off`, `integer_value` being signed integer literal, `floating_value` being signed floating literal and string value
be C-style `"`-guarded string literal, and optional block suffix for specifying blocks for settings that require block
context (for example there can be several color outputs, therefore we must specify color output index as block index).
Below are the examples of setting declarations in global scope:

```
conditional (!wireframe) setting polygon_mode "fill";
conditional (wireframe) setting polygon_mode "wireframe";
setting cull_mode "back";
setting depth_test on;
setting depth_write on;
setting color_output_use_blend on block 0;
setting color_output_source_color_blend_factor "source_color" block 1;
```

## Meta prefixes

Meta prefixes are used to add textual meta tags to struct and buffer fields, that can be later used on higher level to
identify required parameters. Meta prefixes follow the pattern: `meta \( tag (, tag)* \)` with `tag` as any C-style
identifier. Below are the examples of meta prefixes:

```
meta (hidden, model_joint_matrices)
meta (hidden, projection_view_matrix)
```

## Inbuilt types

There is list of currently supported inbuilt types:

- `f1` -- 32-bit floating point scalar.
- `f2`, `f3` and `f4` -- 2, 3 and 4 dimensional vectors of 32-bit floating point scalars.
- `i1` -- 32-bit signed integer scalar.
- `i2`, `i3`, `i4` -- 2, 3 and 4 dimensional vectors of 32-bit signed integer scalars.
- `f3x3`, `f4x4` -- 3x3 and 4x4 column-major matrices of 32-bit floating point scalars.

## Type usage syntax

Type can be specified using syntax: `type_name ((\[ array_dimension_expression \])+ | ...)?` with type_name being 
inbuilt type name or structure name and array_dimension_expression being a compile-time expression that selects size of
array dimension. `...` can be used instead of array suffix in order to declare runtime-sized array. But keep in mind
that runtime sized arrays are only supported in structures and buffers and always should be the last field.
If type is used for structures or buffers, only `global` options can be used inside expression.
Otherwise, `instance` options are allowed.

Below are the examples of types:

```
f3
joint_data_t
f4x4[max_joints]
f4x4...
```

## Structs

Structs are used to declare complex data structures the same way as it is done in C or GLSL.

Struct declaration syntax is:

```
conditional_prefix? struct <struct_name>
{
    (conditional_prefix? meta_prefix? type <field_name>;)+
};
```

Struct declaration example:

```
conditional (enable_skinning) struct joint_data_t
{
    meta (hidden, model_joint_matrices)
    f4x4[max_joints] model_joints;
};
```

## Descriptor sets

There are several inbuilt descriptor sets that correspond to the common usage pattern:

- `set_pass` is advised for data that is passed from render pass like view-projection matrix.
- `set_material` is advised for data that is shared between lots of objects and corresponds to
  high level concept of materials.
- `set_object` is advised for data unique for scene object. For example, object may store its data in its own uniform 
  buffer and update this buffer without changing descriptor set.
- `set_shared` is advised for data that can be shared across multiple objects, but is not global enough to be on 
  material set level. For example, one skeleton or even an array of several skeletons can be shared across multiple
  objects, making instancing possible for them.

Any set keyword inside declaration syntax is called `set_prefix` below.

Hardcoded set names are used to make writing shaders more explicit and easy to understand as render pipeline language
is designed to provide as much information as possible to the high level material system instead of just arbitrary set 
numbers. Also, we have only 4 descriptor sets as it is the minimum guaranteed number of supported sets on modern GPUs.

## Buffers

Buffer is a group variables that serve the same purpose and usually stored in one physical buffer object.
There are several types of buffers:

- `vertex_attribute_buffer` represents buffer of vertex attributes. 
  Fields of this buffer are the attributes of one vertex.
- `instanced_attribute_buffer` represents buffer of per-instance attributes. Fields of this buffer are the attributes
  of one instanced geometry.
- `uniform_buffer` represents a classic uniform buffer object with `std140` memory layout. Requires `set_prefix`.
- `read_only_storage_buffer` represents a classic storage buffer which is read-only and has `std430` memory layout.
  Requires `set_prefix`. The only buffer type that supports runtime sized arrays as tails.
- `vertex_stage_output` is an abstract buffer which is technically not a buffer and used for sharing vertex stage
  data with other pipeline stages.
- `fragment_stage_output` is an abstract buffer which is technically not a buffer and used for fragment stage output.

Buffer declaration syntax is close to struct declaration syntax:

```
conditional_prefix? set_prefix_if_supported_by_type buffer_type <buffer_name>
{
    (conditional_prefix? meta_prefix? type <field_name>;)+
};
```

Buffer declaration examples:

```
vertex_attribute_buffer vertex
{
    f3 position;
    f3 normal;
    f2 uv;

    conditional (enable_skinning && skinning_2_weights) i2 joint_indices;
    conditional (enable_skinning && skinning_2_weights) f2 joint_weights;

    conditional (enable_skinning && skinning_4_weights) i4 joint_indices;
    conditional (enable_skinning && skinning_4_weights) f4 joint_weights;
};

conditional (support_instancing) instanced_attribute_buffer instance_vertex
{
    f4 color_multiplier;

    meta (hidden, model_space_matrix)
    f4x4 model_space;

    conditional (enable_skinning)
    meta (hidden, joint_offset_index)
    i1 joint_offset;
};

conditional (!support_instancing) set_material uniform_buffer material
{
    f4 color_multiplier;
};

conditional (support_instancing && enable_skinning) set_shared read_only_storage_buffer joints
{
    f4x4... transforms;
};
```

Buffers are exposed in metadata (excluding `vertex_stage_output` and `fragment_stage_output` ones). Depending on buffer
type, its fields can be exposed as named parameters, attributes or both. For parameter generation, buffer flattening
is used. It means that buffer data is represented as tree and then only tree leaves are exposed as parameters, where
parameter name is equal to path from tree root to parameter leaf. Runtime sized array generate tail parameters if their 
item type is structure. Also, arrays of structs currently do not participate in parameter generation for simplification 
as it is not needed at the moment.

## Samplers

Samplers are always detached from images and are declared as global variables. Samples declaration syntax is:

```
conditional_prefix set_prefix sampler <sampler_name>;
```

Sampler declaration example:

```
set_material sampler texture_sampler;
```

## Images

Images are declared as global variables and are always separate from samplers. There are several supported image types:

- `image_color_2d` is a usual 2d image that is used to store color data.
- `image_color_3d` is a 3d image with color data.
- `image_color_cube` is a usual cube map with color data.
- `image_color_2d_array` is an arrayed 2d image with color data.
- `image_depth_2d` is a usual 2d image that is used to store depth or depth-stencil data.
- `image_depth_3d` is a 3d image with depth or depth-stencil data.
- `image_depth_cube` is a usual cube map with depth or depth-stencil data.
- `image_depth_2d_array` is an arrayed 2d image with depth or depth-stencil data.

It is allowed to declare arrays of images, however only fixed size one dimension arrays are allowed.
Image declaration example:

```
set_material image_depth_2d[max_shadow_maps] shadow_maps;
set_material image_color_2d_array atlas;
```

There are 2 ways to sample image: `sample` function for usual sampling and `sample_dref` function for sampling depth 
images with depth reference comparison. For all sampling functions the first two arguments are sampler and image,
additional arguments depend on image types.

`sample` function additional arguments are:

- For `sampler_color_2d` and `sampler_depth_2d`: `f2 coordinate`.
- For `sampler_color_3d` and `sampler_depth_3d`: `f3 coordinate`.
- For `sampler_color_cube` and `sampler_depth_cube`: `f3 direction`.
- For `sampler_color_2d_array` and `sampler_depth_cube`: `i1 layer` and `f2 coordinate`.

`sample_dref` function additional arguments are:

- For `sampler_depth_2d`: `f2 coordinate` and `f1 reference`.
- For `sampler_depth_3d`: `f3 coordinate` and `f1 reference`.
- For `sampler_depth_cube`: `f3 direction` and `f1 reference`.
- For `sampler_depth_cube`: `i1 layer`, `f2 coordinate` and `f1 reference`.

Sampler call examples:

```
sample (color_sampler, atlas[2], vertex_output.uv)
sample_dref (depth_sampler, shadow_maps[light.shadow_map_index], projected_coordinate, projected_depth)
```

## Functions

Function declaration syntax is close to C with a few exceptions:

- Function can only return non-array types.
- If function doesn't return anything, `void` should be used instead of return type.
- Functions without arguments must be declared as `<return_type> <function_name> (void)`.
- Every function argument is allowed to have conditional prefix.
- Every function argument must have access class: `in` for constant arguments, `out` for write-only output arguments and
  `in out` for arguments that support both reading and writing into them.

There is also some additional cases where conditionals can be used in function code:

- Scopes can be conditional, for example:

```
conditional (enable_skinning)
{
    // Logic when skinning is enabled.
}
conditional (!enable_skinning)
{
    // Logic when skinning is disabled.
}
```

- There is a conditional alias syntax for situations where we need to refer to different buffers or variables depending
  on pipeline options:

```
conditional (support_instancing) alias (joints, instance_storage.joint_data.model_joints)
conditional (!support_instancing) alias (joints, uniforms.joint_data.model_joints)
// Below, "joints" can be used as a normal variable name.
// Conditional aliases have the same visiblity as variable inside scope.
```
