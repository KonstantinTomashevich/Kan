#pragma once

#include <stddef.h>

#include <kan/api_common/c_header.h>
#include <kan/api_common/core_types.h>
#include <kan/api_common/highlight.h>
#include <kan/universe/universe.h>

// TODO: Rework all the comments out there.

/// \file
/// \brief Provides markup macros for usage with universe preprocessor.
///
/// \par Motivation
/// \parblock
/// Query API is versatile, but it is a bit too verbose in most cases. Verbosity of this API makes it more difficult to
/// write and read mutator code. Therefore, it was decided to introduce special custom preprocessor that uses
/// macro-driven markup to automatically generate verbose code for common use cases.
/// \endparblock
///
/// \par Capabilities
/// \parblock
/// - State query fields are automatically generated from query markup, making it easy to introduce new query to code:
///   just write the queries and required state fields will be autogenerated. Query names follow universe automated
///   lifetime guidelines, therefore they do not require manual deploy and undeploy steps.
///
/// - Simplified query syntax. User no longer needs to manually manage cursors and accesses, only blocks with actual
///   data processing logic are required. For example:
///
///   ```c
///   KAN_UP_SEQUENCE_READ (my_data, my_data_type_t)
///   {
///       // ... your logic here that works on my_data pointer for every instance of my_data_type_t in repository ...
///   }
///   ```
///
/// - Simplified query execution control. User can add macros like `KAN_UP_QUERY_BREAK` to break out of query early
///   or even `KAN_UP_QUERY_RETURN_VALUE` to calculate return value and then close all the accesses and cursors.
///
/// - Specialized access management is still possible through `KAN_UP_ACCESS_ESCAPE` and `KAN_UP_ACCESS_DELETE`.
/// \endparblock
///
/// \par Usage basics
/// \parblock
/// Foundation for query usage is a state: structure that will contain repository query instances. To declare state,
/// use `KAN_UP_GENERATE_STATE_QUERIES` inside any structure you need:
///
/// ```c
/// struct my_mutator_state_t
/// {
///     KAN_UP_GENERATE_STATE_QUERIES (my_mutator);
/// };
/// ```
///
/// Alternatively, there can be states with pre-filled queries (queries created manually, not through preprocessor).
/// State is declared pre-filled when its binding is found before KAN_UP_GENERATE_STATE_QUERIES with this name.
/// In this case, KAN_UP_GENERATE_STATE_QUERIES should never be called for this state.
///
/// State name argument is later used for binding states.
///
/// Binding state means that all queries below (until another binding) are working with the state that has given name
/// and which instance pointer will be available at given state path. If you're using standardized state pointer in
/// every function, which is an advised approach for universe, you can bind state only once for all functions.
///
/// When state is declared and bound, you can use query macros. They are split into several groups:
///
/// - Singleton queries. Their feature is that several singleton queries can share one code block, but they also
///   do not support query break and continue macros. Example:
///
/// ```c
/// KAN_UP_SINGLETON_READ (readonly_singleton, my_first_singleton_type_t)
/// KAN_UP_SINGLETON_WRITE (writable_singleton, my_second_singleton_type_t)
/// {
///     writable_singleton->some_field = readonly_singleton->some_field;
/// }
/// ```
///
/// - Insertion queries. This queries are used for inserting single instance of data, therefore they do not support
///   query break and continue macro. Example:
///
/// ```c
/// KAN_UP_INDEXED_INSERT (new_instance, my_instance_type_t)
/// {
///     new_instance->some_field = some_data;
/// }
/// ```
///
/// - Range queries. These queries operate on several instances of data, executing block for every instance once.
///   They support query break and continue macros. Example:
///
/// ```c
/// KAN_UP_VALUE_READ (instance, my_instance_type_t, key_field, &key_data)
/// {
///     if (instance->other_field == other_data)
///     {
///         found = KAN_TRUE;
///         KAN_UP_QUERY_BREAK;
///     }
/// }
/// ```
/// \endparblock
///
/// \par Limitations
/// \parblock
/// - Space queries are not supported, because it is unclear how to automatically generate them inside state as
///   they require additional meta generation for their state fields, which is out of scope for now.
/// - `KAN_UP_QUERY_BREAK` and `KAN_UP_QUERY_CONTINUE ` should be used with care: they're just break and continue
///   keywords that manage accesses and cursors before executing, therefore using them inside normal `for`, `switch` or
///   `while` will result in undefined behavior.
/// \endparblock
///
/// \par Autocomplete
/// \parblock
/// Macros provided in this file should provide enough information for code highlight and autocomplete features
/// to work in most IDEs.
/// \endparblock

KAN_C_HEADER_BEGIN

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_GENERATE_STATE_QUERIES(STATE_NAME)                                                                  \
        /* Highlight-autocomplete replacement. */                                                                      \
        kan_memory_size_t STATE_NAME##_fake_placeholder_field;
#else
#    define KAN_UP_GENERATE_STATE_QUERIES(STATE_NAME) CUSHION_STATEMENT_ACCUMULATOR (universe_queries_##STATE_NAME)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_BIND_STATE(STATE_NAME, ...) /* No highlight-time replacement. */
#else
#    define KAN_UP_BIND_STATE(STATE_NAME, ...)                                                                         \
        CUSHION_STATEMENT_ACCUMULATOR_REF (universe_queries, universe_queries_##STATE_NAME)                            \
        CUSHION_SNIPPET (KAN_UP_STATE_PATH, (__VA_ARGS__))
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_BIND_STATE_FIELDLESS(STATE_NAME, ...) /* No highlight-time replacement. */
#else
#    define KAN_UP_BIND_STATE_FIELDLESS(STATE_NAME, ...)                                                               \
        CUSHION_STATEMENT_ACCUMULATOR_UNREF (universe_queries)                                                         \
        CUSHION_SNIPPET (KAN_UP_STATE_PATH, (__VA_ARGS__))
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_UNBIND_STATE /* No highlight-time replacement. */
#else
#    define KAN_UP_UNBIND_STATE                                                                                        \
        CUSHION_STATEMENT_ACCUMULATOR_UNREF (universe_queries)                                                         \
        CUSHION_SNIPPET (KAN_UP_STATE_PATH, (kan_up_state_path_not_initialized))
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_MUTATOR_RELEASE_JOB_ON_RETURN
#else
#    define KAN_UP_MUTATOR_RELEASE_JOB_ON_RETURN                                                                       \
        CUSHION_DEFER                                                                                                  \
        {                                                                                                              \
            kan_cpu_job_release (job);                                                                                 \
        }
#endif

#define KAN_UP_ACCESS_ESCAPE(TARGET, NAME)                                                                             \
    TARGET = NAME##_access;                                                                                            \
    NAME##_access_expired = KAN_TRUE

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_ACCESS_DELETE(NAME)                                                                                 \
        /* Highlight results in error with "no variable" if query highlight didn't declare this variable marking       \
         * delete as allowed for this query type. */                                                                   \
        delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                                \
        NAME = NULL;                                                                                                   \
        NAME##_access_expired = KAN_TRUE
#else
#    define KAN_UP_ACCESS_DELETE(NAME)                                                                                 \
        KAN_SNIPPET_DELETE_ACCESS_##NAME;                                                                              \
        NAME = NULL;                                                                                                   \
        NAME##_access_expired = KAN_TRUE
#endif

#define KAN_UP_INTERNAL_STATE_FIELD(QUERY_TYPE, FIELD_NAME)                                                            \
    CUSHION_STATEMENT_ACCUMULATOR_PUSH (universe_queries, unique, optional)                                            \
    {                                                                                                                  \
        struct QUERY_TYPE FIELD_NAME;                                                                                  \
    }

#define KAN_UP_INTERNAL_ACCESS_DEFER(NAME, CLOSE_FUNCTION)                                                             \
    kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                      \
    CUSHION_DEFER                                                                                                      \
    {                                                                                                                  \
        if (!NAME##_access_expired)                                                                                    \
        {                                                                                                              \
            CLOSE_FUNCTION (&NAME##_access);                                                                           \
        }                                                                                                              \
    }

#define KAN_UP_INTERNAL_SINGLETON(NAME, TYPE, ACCESS, QUALIFIER)                                                       \
    KAN_UP_INTERNAL_STATE_FIELD (kan_repository_singleton_##ACCESS##_query_t,                                          \
                                 ACCESS##__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE))                                    \
                                                                                                                       \
    struct kan_repository_singleton_##ACCESS##_access_t NAME##_access =                                                \
        kan_repository_singleton_##ACCESS##_query_execute (                                                            \
            &KAN_UP_STATE_PATH->ACCESS##__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE));                                    \
                                                                                                                       \
    QUALIFIER struct TYPE *NAME = kan_repository_singleton_##ACCESS##_access_resolve (&NAME##_access);                 \
    KAN_UP_INTERNAL_ACCESS_DEFER (NAME, kan_repository_singleton_##ACCESS##_access_close)

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SINGLETON_READ(NAME, TYPE)                                                                          \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;
#else
#    define KAN_UP_SINGLETON_READ(NAME, TYPE) KAN_UP_INTERNAL_SINGLETON (NAME, TYPE, read, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SINGLETON_WRITE(NAME, TYPE)                                                                         \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;
#else
#    define KAN_UP_SINGLETON_WRITE(NAME, TYPE) KAN_UP_INTERNAL_SINGLETON (NAME, TYPE, write, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INDEXED_INSERT(NAME, TYPE)                                                                          \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;
#else
#    define KAN_UP_INDEXED_INSERT(NAME, TYPE)                                                                          \
        {                                                                                                              \
            KAN_UP_INTERNAL_STATE_FIELD (kan_repository_indexed_insert_query_t,                                        \
                                         insert__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE))                              \
                                                                                                                       \
            struct kan_repository_indexed_insertion_package_t NAME##_package =                                         \
                kan_repository_indexed_insert_query_execute (                                                          \
                    &KAN_UP_STATE_PATH->insert__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE));                              \
                                                                                                                       \
            struct TYPE *NAME = kan_repository_indexed_insertion_package_get (&NAME##_package);                        \
            CUSHION_DEFER                                                                                              \
            {                                                                                                          \
                kan_repository_indexed_insertion_package_submit (&NAME##_package);                                     \
            }                                                                                                          \
                                                                                                                       \
            __CUSHION_WRAPPED__                                                                                        \
        }
#endif

#define KAN_UP_INTERNAL_SEQUENCE(NAME, TYPE, ACCESS, QUALIFIER)                                                        \
    {                                                                                                                  \
        KAN_UP_INTERNAL_STATE_FIELD (kan_repository_indexed_sequence_##ACCESS##_query_t,                               \
                                     ACCESS##_sequence__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE))                       \
                                                                                                                       \
        struct kan_repository_indexed_sequence_##ACCESS##_cursor_t NAME##_cursor =                                     \
            kan_repository_indexed_sequence_##ACCESS##_query_execute (                                                 \
                &KAN_UP_STATE_PATH->ACCESS##_sequence__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE));                       \
                                                                                                                       \
        CUSHION_DEFER                                                                                                  \
        {                                                                                                              \
            kan_repository_indexed_sequence_##ACCESS##_cursor_close (&NAME##_cursor);                                  \
        }                                                                                                              \
                                                                                                                       \
        while (KAN_TRUE)                                                                                               \
        {                                                                                                              \
            struct kan_repository_indexed_sequence_##ACCESS##_access_t NAME##_access =                                 \
                kan_repository_indexed_sequence_##ACCESS##_cursor_next (&NAME##_cursor);                               \
            QUALIFIER struct TYPE *NAME = kan_repository_indexed_sequence_##ACCESS##_access_resolve (&NAME##_access);  \
                                                                                                                       \
            if (NAME)                                                                                                  \
            {                                                                                                          \
                KAN_UP_INTERNAL_ACCESS_DEFER (NAME, kan_repository_indexed_sequence_##ACCESS##_access_close)           \
                CUSHION_SNIPPET (KAN_SNIPPET_DELETE_ACCESS_##NAME,                                                     \
                                 kan_repository_indexed_sequence_##ACCESS##_access_delete (&NAME##_access))            \
                                                                                                                       \
                __CUSHION_WRAPPED__                                                                                    \
            }                                                                                                          \
            else                                                                                                       \
            {                                                                                                          \
                break;                                                                                                 \
            }                                                                                                          \
        }                                                                                                              \
    }

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SEQUENCE_READ(NAME, TYPE)                                                                           \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        struct kan_repository_indexed_sequence_read_access_t NAME##_access = {0};                                      \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SEQUENCE_READ(NAME, TYPE) KAN_UP_INTERNAL_SEQUENCE (NAME, TYPE, read, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SEQUENCE_UPDATE(NAME, TYPE)                                                                         \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        struct kan_repository_indexed_sequence_update_access_t NAME##_access = {0};                                    \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SEQUENCE_UPDATE(NAME, TYPE) KAN_UP_INTERNAL_SEQUENCE (NAME, TYPE, update, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SEQUENCE_DELETE(NAME, TYPE)                                                                         \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        struct kan_repository_indexed_sequence_delete_access_t NAME##_access = {0};                                    \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SEQUENCE_DELETE(NAME, TYPE) KAN_UP_INTERNAL_SEQUENCE (NAME, TYPE, delete, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SEQUENCE_WRITE(NAME, TYPE)                                                                          \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        struct kan_repository_indexed_sequence_write_access_t NAME##_access = {0};                                     \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SEQUENCE_WRITE(NAME, TYPE) KAN_UP_INTERNAL_SEQUENCE (NAME, TYPE, write, )
#endif

#define KAN_UP_INTERNAL_VALUE(NAME, TYPE, FIELD, ARGUMENT_POINTER, ACCESS, QUALIFIER)                                  \
    {                                                                                                                  \
        KAN_UP_INTERNAL_STATE_FIELD (kan_repository_indexed_value_##ACCESS##_query_t,                                  \
                                     ACCESS##_value__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE)##__##FIELD)               \
                                                                                                                       \
        struct kan_repository_indexed_value_##ACCESS##_cursor_t NAME##_cursor =                                        \
            kan_repository_indexed_value_##ACCESS##_query_execute (                                                    \
                &KAN_UP_STATE_PATH->ACCESS##_value__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE)##__##FIELD,                \
                ARGUMENT_POINTER);                                                                                     \
                                                                                                                       \
        CUSHION_DEFER                                                                                                  \
        {                                                                                                              \
            kan_repository_indexed_value_##ACCESS##_cursor_close (&NAME##_cursor);                                     \
        }                                                                                                              \
                                                                                                                       \
        while (KAN_TRUE)                                                                                               \
        {                                                                                                              \
            struct kan_repository_indexed_value_##ACCESS##_access_t NAME##_access =                                    \
                kan_repository_indexed_value_##ACCESS##_cursor_next (&NAME##_cursor);                                  \
            QUALIFIER struct TYPE *NAME = kan_repository_indexed_value_##ACCESS##_access_resolve (&NAME##_access);     \
                                                                                                                       \
            if (NAME)                                                                                                  \
            {                                                                                                          \
                KAN_UP_INTERNAL_ACCESS_DEFER (NAME, kan_repository_indexed_value_##ACCESS##_access_close)              \
                CUSHION_SNIPPET (KAN_SNIPPET_DELETE_ACCESS_##NAME,                                                     \
                                 kan_repository_indexed_value_##ACCESS##_access_delete (&NAME##_access))               \
                                                                                                                       \
                __CUSHION_WRAPPED__                                                                                    \
            }                                                                                                          \
            else                                                                                                       \
            {                                                                                                          \
                break;                                                                                                 \
            }                                                                                                          \
        }                                                                                                              \
    }

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_VALUE_READ(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                     \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_value_read_access_t NAME##_access = {0};                                         \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_VALUE_READ(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                     \
        KAN_UP_INTERNAL_VALUE (NAME, TYPE, FIELD, ARGUMENT_POINTER, read, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_VALUE_UPDATE(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                   \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_value_update_access_t NAME##_access = {0};                                       \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_VALUE_UPDATE(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                   \
        KAN_UP_INTERNAL_VALUE (NAME, TYPE, FIELD, ARGUMENT_POINTER, update, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_VALUE_DELETE(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                   \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_value_delete_access_t NAME##_access = {0};                                       \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_VALUE_DELETE(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                   \
        KAN_UP_INTERNAL_VALUE (NAME, TYPE, FIELD, ARGUMENT_POINTER, delete, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_VALUE_WRITE(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                    \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_value_write_access_t NAME##_access = {0};                                        \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_VALUE_WRITE(NAME, TYPE, FIELD, ARGUMENT_POINTER)                                                    \
        KAN_UP_INTERNAL_VALUE (NAME, TYPE, FIELD, ARGUMENT_POINTER, write, )
#endif

#define KAN_UP_INTERNAL_SIGNAL(NAME, TYPE, FIELD, LITERAL_VALUE, ACCESS, QUALIFIER)                                    \
    {                                                                                                                  \
        KAN_UP_INTERNAL_STATE_FIELD (kan_repository_indexed_signal_##ACCESS##_query_t,                                 \
                                     ACCESS##_signal__##__CUSHION_EVALUATED_ARGUMENT__ (                               \
                                         TYPE)##__##FIELD##__##__CUSHION_EVALUATED_ARGUMENT__ (LITERAL_VALUE))         \
                                                                                                                       \
        struct kan_repository_indexed_signal_##ACCESS##_cursor_t NAME##_cursor =                                       \
            kan_repository_indexed_signal_##ACCESS##_query_execute (                                                   \
                &KAN_UP_STATE_PATH->ACCESS##_signal__##__CUSHION_EVALUATED_ARGUMENT__ (                                \
                    TYPE)##__##FIELD##__##__CUSHION_EVALUATED_ARGUMENT__ (LITERAL_VALUE));                             \
                                                                                                                       \
        CUSHION_DEFER                                                                                                  \
        {                                                                                                              \
            kan_repository_indexed_signal_##ACCESS##_cursor_close (&NAME##_cursor);                                    \
        }                                                                                                              \
                                                                                                                       \
        while (KAN_TRUE)                                                                                               \
        {                                                                                                              \
            struct kan_repository_indexed_signal_##ACCESS##_access_t NAME##_access =                                   \
                kan_repository_indexed_signal_##ACCESS##_cursor_next (&NAME##_cursor);                                 \
            QUALIFIER struct TYPE *NAME = kan_repository_indexed_signal_##ACCESS##_access_resolve (&NAME##_access);    \
                                                                                                                       \
            if (NAME)                                                                                                  \
            {                                                                                                          \
                KAN_UP_INTERNAL_ACCESS_DEFER (NAME, kan_repository_indexed_signal_##ACCESS##_access_close)             \
                CUSHION_SNIPPET (KAN_SNIPPET_DELETE_ACCESS_##NAME,                                                     \
                                 kan_repository_indexed_signal_##ACCESS##_access_delete (&NAME##_access))              \
                                                                                                                       \
                __CUSHION_WRAPPED__                                                                                    \
            }                                                                                                          \
            else                                                                                                       \
            {                                                                                                          \
                break;                                                                                                 \
            }                                                                                                          \
        }                                                                                                              \
    }

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SIGNAL_READ(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                      \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_signal_read_access_t NAME##_access = {0};                                        \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SIGNAL_READ(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                      \
        KAN_UP_INTERNAL_SIGNAL (NAME, TYPE, FIELD, LITERAL_SIGNAL, read, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SIGNAL_UPDATE(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                    \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_signal_update_access_t NAME##_access = {0};                                      \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SIGNAL_UPDATE(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                    \
        KAN_UP_INTERNAL_SIGNAL (NAME, TYPE, FIELD, LITERAL_SIGNAL, update, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SIGNAL_DELETE(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                    \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_signal_delete_access_t NAME##_access = {0};                                      \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SIGNAL_DELETE(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                    \
        KAN_UP_INTERNAL_SIGNAL (NAME, TYPE, FIELD, LITERAL_SIGNAL, delete, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_SIGNAL_WRITE(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                     \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_signal_write_access_t NAME##_access = {0};                                       \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_SIGNAL_WRITE(NAME, TYPE, FIELD, LITERAL_SIGNAL)                                                     \
        KAN_UP_INTERNAL_SIGNAL (NAME, TYPE, FIELD, LITERAL_SIGNAL, write, )
#endif

#define KAN_UP_INTERNAL_INTERVAL(NAME, TYPE, FIELD, MIN_POINTER, MAX_POINTER, ACCESS, DIRECTION, QUALIFIER)            \
    {                                                                                                                  \
        KAN_UP_INTERNAL_STATE_FIELD (kan_repository_indexed_interval_##ACCESS##_query_t,                               \
                                     ACCESS##_interval__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE)##__##FIELD)            \
                                                                                                                       \
        struct kan_repository_indexed_interval_##DIRECTION##_##ACCESS##_cursor_t NAME##_cursor =                       \
            kan_repository_indexed_interval_##ACCESS##_query_execute_##DIRECTION (                                     \
                &KAN_UP_STATE_PATH->ACCESS##_interval__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE)##__##FIELD,             \
                MIN_POINTER, MAX_POINTER);                                                                             \
                                                                                                                       \
        CUSHION_DEFER                                                                                                  \
        {                                                                                                              \
            kan_repository_indexed_interval_##DIRECTION##_##ACCESS##_cursor_close (&NAME##_cursor);                    \
        }                                                                                                              \
                                                                                                                       \
        while (KAN_TRUE)                                                                                               \
        {                                                                                                              \
            struct kan_repository_indexed_interval_##ACCESS##_access_t NAME##_access =                                 \
                kan_repository_indexed_interval_##DIRECTION##_##ACCESS##_cursor_next (&NAME##_cursor);                 \
            QUALIFIER struct TYPE *NAME = kan_repository_indexed_interval_##ACCESS##_access_resolve (&NAME##_access);  \
                                                                                                                       \
            if (NAME)                                                                                                  \
            {                                                                                                          \
                KAN_UP_INTERNAL_ACCESS_DEFER (NAME, kan_repository_indexed_interval_##ACCESS##_access_close)           \
                CUSHION_SNIPPET (KAN_SNIPPET_DELETE_ACCESS_##NAME,                                                     \
                                 kan_repository_indexed_interval_##ACCESS##_access_delete (&NAME##_access))            \
                                                                                                                       \
                __CUSHION_WRAPPED__                                                                                    \
            }                                                                                                          \
            else                                                                                                       \
            {                                                                                                          \
                break;                                                                                                 \
            }                                                                                                          \
        }                                                                                                              \
    }

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_ASCENDING_READ(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)              \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_read_access_t NAME##_access = {0};                                      \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_ASCENDING_READ(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)              \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, read, ascending, const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_ASCENDING_UPDATE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)            \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_update_access_t NAME##_access = {0};                                    \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_ASCENDING_UPDATE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)            \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, update, ascending, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_ASCENDING_DELETE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)            \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_delete_access_t NAME##_access = {0};                                    \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_ASCENDING_DELETE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)            \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, delete, ascending,    \
                                  const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_ASCENDING_WRITE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)             \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_write_access_t NAME##_access = {0};                                     \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_ASCENDING_WRITE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)             \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, write, ascending, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_DESCENDING_READ(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)             \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_read_access_t NAME##_access = {0};                                      \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_DESCENDING_READ(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)             \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, read, descending,     \
                                  const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_DESCENDING_UPDATE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)           \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_update_access_t NAME##_access = {0};                                    \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_DESCENDING_UPDATE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)           \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, update, descending, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_DESCENDING_DELETE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)           \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;                                                                                \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_delete_access_t NAME##_access = {0};                                    \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_DESCENDING_DELETE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)           \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, delete, descending,   \
                                  const)
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_INTERVAL_DESCENDING_WRITE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)            \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;                                                                                      \
        KAN_HIGHLIGHT_STRUCT_FIELD (TYPE, FIELD)                                                                       \
        struct kan_repository_indexed_interval_write_access_t NAME##_access = {0};                                     \
        kan_bool_t NAME##_access_expired = KAN_FALSE;                                                                  \
        kan_bool_t delete_allowed_for_highlight_##NAME = KAN_TRUE;                                                     \
        for (kan_loop_size_t fake_index_##NAME = 0u; fake_index_##NAME < 1u; ++fake_index_##NAME)
#else
#    define KAN_UP_INTERVAL_DESCENDING_WRITE(NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER)            \
        KAN_UP_INTERNAL_INTERVAL (NAME, TYPE, FIELD, ARGUMENT_MIN_POINTER, ARGUMENT_MAX_POINTER, write, descending, )
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_EVENT_INSERT(NAME, TYPE)                                                                            \
        /* Highlight-autocomplete replacement. */                                                                      \
        struct TYPE *NAME = NULL;
#else
#    define KAN_UP_EVENT_INSERT(NAME, TYPE)                                                                            \
        {                                                                                                              \
            KAN_UP_INTERNAL_STATE_FIELD (kan_repository_event_insert_query_t,                                          \
                                         insert__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE))                              \
                                                                                                                       \
            struct kan_repository_event_insertion_package_t NAME##_package =                                           \
                kan_repository_event_insert_query_execute (                                                            \
                    &KAN_UP_STATE_PATH->insert__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE));                              \
                                                                                                                       \
            struct TYPE *NAME = kan_repository_event_insertion_package_get (&NAME##_package);                          \
            if (NAME)                                                                                                  \
            {                                                                                                          \
                CUSHION_DEFER                                                                                          \
                {                                                                                                      \
                    kan_repository_event_insertion_package_submit (&NAME##_package);                                   \
                }                                                                                                      \
                                                                                                                       \
                __CUSHION_WRAPPED__                                                                                    \
            }                                                                                                          \
        }
#endif

#if defined(CMAKE_UNIT_FRAMEWORK_HIGHLIGHT)
#    define KAN_UP_EVENT_FETCH(NAME, TYPE)                                                                             \
        /* Highlight-autocomplete replacement. */                                                                      \
        const struct TYPE *NAME = NULL;
#else
#    define KAN_UP_EVENT_FETCH(NAME, TYPE)                                                                             \
        {                                                                                                              \
            KAN_UP_INTERNAL_STATE_FIELD (kan_repository_event_fetch_query_t,                                           \
                                         fetch__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE))                               \
                                                                                                                       \
            while (KAN_TRUE)                                                                                           \
            {                                                                                                          \
                struct kan_repository_event_read_access_t NAME##_access = kan_repository_event_fetch_query_next (      \
                    &KAN_UP_STATE_PATH->fetch__##__CUSHION_EVALUATED_ARGUMENT__ (TYPE));                               \
                const struct TYPE *NAME = kan_repository_event_read_access_resolve (&NAME##_access);                   \
                                                                                                                       \
                if (NAME)                                                                                              \
                {                                                                                                      \
                    KAN_UP_INTERNAL_ACCESS_DEFER (NAME, kan_repository_event_read_access_close)                        \
                                                                                                                       \
                    __CUSHION_WRAPPED__                                                                                \
                }                                                                                                      \
                else                                                                                                   \
                {                                                                                                      \
                    break;                                                                                             \
                }                                                                                                      \
            }                                                                                                          \
        }
#endif

KAN_C_HEADER_END
